<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess ARN - Comprehensive Learning System</title>
    <style>
        /* Same CSS as before */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            gap: 20px;
        }

        .board-container {
            flex: 1;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }

        .stats-container {
            flex: 1;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        h1,
        h2,
        h3 {
            color: #2c3e50;
            margin-top: 0;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        .simple-board {
            width: 100%;
            aspect-ratio: 1/1;
            max-width: 400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            border: 2px solid #333;
            background-color: #ddd;
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .piece {
            width: 70%;
            height: 70%;
            border-radius: 50%;
            position: relative;
        }

        .piece.white {
            background-color: #fff;
            border: 2px solid #333;
        }

        .piece.black {
            background-color: #333;
            border: 2px solid #000;
        }

        .piece::after {
            content: attr(data-piece);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: bold;
        }

        .piece.white::after {
            color: #333;
        }

        .piece.black::after {
            color: #fff;
        }

        .controls {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        button.success {
            background-color: #2ecc71;
        }

        button.success:hover {
            background-color: #27ae60;
        }

        button.warning {
            background-color: #f39c12;
        }

        button.warning:hover {
            background-color: #e67e22;
        }

        button.danger {
            background-color: #e74c3c;
        }

        button.danger:hover {
            background-color: #c0392b;
        }

        select,
        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-card {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            font-size: 12px;
            color: #7f8c8d;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
        }

        .progress-bar {
            height: 8px;
            background-color: #ecf0f1;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .progress-fill {
            height: 100%;
            background-color: #3498db;
            width: 0%;
            transition: width 0.5s;
        }

        .log-container {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            flex-grow: 1;
        }

        .log-entry {
            margin: 0;
            padding: 2px 0;
            border-bottom: 1px solid #34495e;
        }

        .log-timestamp {
            color: #95a5a6;
            margin-right: 5px;
        }

        .thinking-indicator {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .thinking-dot {
            width: 8px;
            height: 8px;
            background-color: #3498db;
            border-radius: 50%;
            margin-right: 5px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.8);
                opacity: 0.5;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
        }

        .thinking-text {
            font-size: 14px;
            color: #7f8c8d;
        }

        .hidden {
            display: none;
        }

        .game-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }

        .turn-indicator {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .turn-indicator.white {
            color: #2c3e50;
        }

        .turn-indicator.black {
            color: #34495e;
        }

        .move-history {
            height: 100px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
            border: 1px solid #ddd;
            padding: 5px;
            margin-top: 10px;
        }

        .breakthrough-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .breakthrough-item {
            background-color: #f8f9fa;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            border-left: 3px solid #3498db;
        }

        .breakthrough-item h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
        }

        .breakthrough-level {
            display: inline-block;
            padding: 2px 6px;
            background-color: #3498db;
            color: white;
            border-radius: 3px;
            font-size: 12px;
            margin-left: 5px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .speed-label {
            margin-right: 10px;
            font-size: 14px;
        }

        .exploration-slider {
            margin-top: 15px;
        }

        .exploration-slider label {
            display: block;
            margin-bottom: 5px;
        }

        .exploration-slider input {
            width: 100%;
        }

        .exploration-value {
            text-align: center;
            margin-top: 5px;
            font-weight: bold;
        }

        .exploration-description {
            margin-top: 5px;
            font-size: 12px;
            color: #666;
            font-style: italic;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <h1>Chess ARN - Comprehensive Learning System</h1>

    <div class="container">
        <div class="board-container">
            <h2>Game Board</h2>

            <div class="simple-board" id="chess-board">
                <!-- Board will be generated by JavaScript -->
            </div>

            <div class="game-info">
                <div class="turn-indicator white" id="turn-indicator">White to move</div>
                <div id="game-status">Game in progress</div>
                <div class="move-history" id="move-history"></div>
            </div>

            <div class="controls">
                <button id="start-learning" class="success">Start Learning</button>
                <button id="pause-learning" class="warning">Pause</button>
                <button id="stop-learning" class="danger">Stop</button>
                <button id="single-move" class="warning">Make Single Move</button>

                <div class="speed-control">
                    <span class="speed-label">Speed:</span>
                    <select id="game-speed">
                        <option value="1000">Slow</option>
                        <option value="300">Normal</option>
                        <option value="50" selected>Fast</option>
                        <option value="10">Ultra Fast</option>
                        <option value="0">Instant</option>
                    </select>
                </div>
            </div>

            <div class="exploration-slider">
                <label for="exploration-rate">Exploration Strategy: <span id="exploration-value">50% - Balanced
                        Learning</span></label>
                <input type="range" id="exploration-rate" min="0" max="100" value="50">
                <div class="exploration-value">
                    <span>Shoot to Kill</span>
                    <span style="float:right">Total Exploration</span>
                </div>
                <div class="exploration-description" id="exploration-description">
                    Balances finding the best moves with exploring new possibilities.
                </div>
            </div>
        </div>

        <div class="stats-container">
            <h2>Learning Statistics</h2>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Games Played</div>
                    <div class="stat-value" id="games-played">0</div>
                </div>

                <div class="stat-card">
                    <div class="stat-label">Positions Learned</div>
                    <div class="stat-value" id="positions-learned">0</div>
                </div>

                <div class="stat-card">
                    <div class="stat-label">Unique Moves Tried</div>
                    <div class="stat-value" id="unique-moves">0</div>
                </div>

                <div class="stat-card">
                    <div class="stat-label">Position Coverage</div>
                    <div class="stat-value" id="position-coverage">0%</div>
                </div>

                <div class="stat-card">
                    <div class="stat-label">White Wins</div>
                    <div class="stat-value" id="white-wins">0</div>
                </div>

                <div class="stat-card">
                    <div class="stat-label">Black Wins</div>
                    <div class="stat-value" id="black-wins">0</div>
                </div>

                <div class="stat-card">
                    <div class="stat-label">Exploration Level</div>
                    <div class="stat-value" id="exploration-level">50%</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="exploration-progress" style="width: 50%;"></div>
                    </div>
                </div>

                <div class="stat-card">
                    <div class="stat-label">Learning Depth</div>
                    <div class="stat-value" id="learning-depth">0</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="learning-progress" style="width: 0%;"></div>
                    </div>
                </div>
            </div>

            <h3>Recent Discoveries</h3>
            <div class="breakthrough-list" id="breakthrough-list">
                <!-- Breakthroughs will be added here -->
            </div>

            <div class="thinking-indicator hidden" id="thinking-indicator">
                <div class="thinking-dot"></div>
                <div class="thinking-dot" style="animation-delay: 0.2s;"></div>
                <div class="thinking-dot" style="animation-delay: 0.4s;"></div>
                <div class="thinking-text">ARN is learning...</div>
            </div>

            <div class="log-container" id="log-container">
                <!-- Log entries will appear here -->
                <div class="log-entry"><span class="log-timestamp">[00:00:00]</span> Chess ARN initialized</div>
            </div>
        </div>
    </div>

    <script type="module">

        import { OptimizedChessARN } from './chessarn1.js';
        /**
         * Simple Chess Game Implementation
         */
        class SimpleChess {
            constructor() {
                this.board = this.createEmptyBoard();
                this.currentPlayer = 'white';
                this.gameOver = false;
                this.checkmateColor = null;
                this.moveHistory = [];

                // Initialize the board
                this.setupBoard();

                // Piece values for evaluation
                this.pieceValues = {
                    'p': 100,   // pawn
                    'n': 320,   // knight
                    'b': 330,   // bishop
                    'r': 500,   // rook
                    'q': 900,   // queen
                    'k': 20000  // king
                };

                console.log("SimpleChess initialized");
            }

            /**
             * Create an empty board
             */
            createEmptyBoard() {
                const board = [];
                for (let i = 0; i < 8; i++) {
                    board[i] = Array(8).fill(null);
                }
                return board;
            }

            /**
             * Set up the initial board position
             */
            setupBoard() {
                // Reset the board
                this.board = this.createEmptyBoard();

                // Set up pawns
                for (let col = 0; col < 8; col++) {
                    this.board[1][col] = { type: 'p', color: 'black' };
                    this.board[6][col] = { type: 'p', color: 'white' };
                }

                // Set up other pieces
                const backRowPieces = ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'];

                for (let col = 0; col < 8; col++) {
                    this.board[0][col] = { type: backRowPieces[col], color: 'black' };
                    this.board[7][col] = { type: backRowPieces[col], color: 'white' };
                }

                // Reset game state
                this.currentPlayer = 'white';
                this.gameOver = false;
                this.checkmateColor = null;
                this.moveHistory = [];

                // Render the board
                this.renderBoard();
                this.updateGameStatus();

                console.log("Board setup complete");
            }

            /**
             * Render the board on the page
             */
            renderBoard() {
                const boardElement = document.getElementById('chess-board');
                if (!boardElement) {
                    console.error("Chess board element not found");
                    return;
                }

                // Clear the board
                boardElement.innerHTML = '';

                // Create squares and pieces
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;

                        const piece = this.board[row][col];
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = `piece ${piece.color}`;
                            pieceElement.dataset.piece = this.getPieceSymbol(piece.type);
                            square.appendChild(pieceElement);
                        }

                        boardElement.appendChild(square);
                    }
                }
            }

            /**
             * Get the symbol for a piece type
             */
            getPieceSymbol(type) {
                const symbols = {
                    'p': '♟',
                    'r': '♜',
                    'n': '♞',
                    'b': '♝',
                    'q': '♛',
                    'k': '♚'
                };
                return symbols[type] || '';
            }

            /**
             * Update the game status display
             */
            updateGameStatus() {
                const turnIndicator = document.getElementById('turn-indicator');
                const gameStatus = document.getElementById('game-status');

                if (turnIndicator) {
                    turnIndicator.textContent = `${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)} to move`;
                    turnIndicator.className = `turn-indicator ${this.currentPlayer}`;
                }

                if (gameStatus) {
                    if (this.gameOver) {
                        if (this.checkmateColor) {
                            const winner = this.checkmateColor === 'white' ? 'Black' : 'White';
                            gameStatus.textContent = `Game over. ${winner} wins by checkmate.`;
                        } else {
                            gameStatus.textContent = 'Game over. Draw.';
                        }
                    } else {
                        gameStatus.textContent = 'Game in progress';
                    }
                }
            }

            /**
             * Execute a move
             */
            executeMove(move) {
                console.log("Executing move:", move);

                // Get the piece
                const piece = this.board[move.from.row][move.from.col];
                if (!piece || piece.color !== this.currentPlayer) {
                    console.error("Invalid move: No piece or wrong color", move, piece);
                    return false;
                }

                // Move the piece
                this.board[move.to.row][move.to.col] = piece;
                this.board[move.from.row][move.from.col] = null;

                // Record the move
                const moveNotation = this.getMoveNotation(move);
                this.moveHistory.push(moveNotation);

                // Update move history display
                this.updateMoveHistory();

                // Check for game over conditions
                this.checkGameOver();

                // Switch player
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';

                // Update the display
                this.renderBoard();
                this.updateGameStatus();

                return true;
            }

            /**
             * Update the move history display
             */
            updateMoveHistory() {
                const historyElement = document.getElementById('move-history');
                if (!historyElement) return;

                let historyText = '';
                for (let i = 0; i < this.moveHistory.length; i += 2) {
                    const moveNumber = Math.floor(i / 2) + 1;
                    const whiteMove = this.moveHistory[i];
                    const blackMove = i + 1 < this.moveHistory.length ? this.moveHistory[i + 1] : '';

                    historyText += `${moveNumber}. ${whiteMove} ${blackMove} `;
                }

                historyElement.textContent = historyText;
                historyElement.scrollTop = historyElement.scrollHeight;
            }

            /**
             * Check if the game is over
             */
            checkGameOver() {
                // For simplicity, we'll just check if a king is missing
                let whiteKing = false;
                let blackKing = false;

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.type === 'k') {
                            if (piece.color === 'white') whiteKing = true;
                            if (piece.color === 'black') blackKing = true;
                        }
                    }
                }

                if (!whiteKing) {
                    this.gameOver = true;
                    this.checkmateColor = 'white';
                } else if (!blackKing) {
                    this.gameOver = true;
                    this.checkmateColor = 'black';
                }

                // Check for stalemate (simplified)
                const nextPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                if (this.getAllPossibleMoves(nextPlayer).length === 0) {
                    this.gameOver = true;
                }

                // Also end game after 100 moves to prevent infinite games
                if (this.moveHistory.length >= 200) {
                    this.gameOver = true;
                }
            }

            /**
             * Get all possible moves for a player
             */
            getAllPossibleMoves(color) {
                const moves = [];

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === color) {
                            const pieceMoves = this.getPossibleMovesForPiece(row, col);
                            moves.push(...pieceMoves);
                        }
                    }
                }

                return moves;
            }

            /**
             * Get possible moves for a piece
             */
            getPossibleMovesForPiece(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];

                const moves = [];

                // For simplicity, we'll just generate some basic moves
                // In a real chess implementation, this would be much more complex

                // Pawns
                if (piece.type === 'p') {
                    const direction = piece.color === 'white' ? -1 : 1;

                    // Move forward one square
                    if (this.isValidSquare(row + direction, col) && !this.board[row + direction][col]) {
                        moves.push({
                            from: { row, col },
                            to: { row: row + direction, col }
                        });
                    }

                    // Capture diagonally
                    for (let colOffset of [-1, 1]) {
                        const newCol = col + colOffset;
                        if (this.isValidSquare(row + direction, newCol)) {
                            const targetPiece = this.board[row + direction][newCol];
                            if (targetPiece && targetPiece.color !== piece.color) {
                                moves.push({
                                    from: { row, col },
                                    to: { row: row + direction, col: newCol }
                                });
                            }
                        }
                    }
                }

                // Knights
                if (piece.type === 'n') {
                    const knightMoves = [
                        { row: row - 2, col: col - 1 },
                        { row: row - 2, col: col + 1 },
                        { row: row - 1, col: col - 2 },
                        { row: row - 1, col: col + 2 },
                        { row: row + 1, col: col - 2 },
                        { row: row + 1, col: col + 2 },
                        { row: row + 2, col: col - 1 },
                        { row: row + 2, col: col + 1 }
                    ];

                    for (const move of knightMoves) {
                        if (this.isValidSquare(move.row, move.col)) {
                            const targetPiece = this.board[move.row][move.col];
                            if (!targetPiece || targetPiece.color !== piece.color) {
                                moves.push({
                                    from: { row, col },
                                    to: { row: move.row, col: move.col }
                                });
                            }
                        }
                    }
                }

                // For other pieces, we'll just allow them to move to any empty square or capture
                // This is not real chess logic, just a simplified version for demonstration
                if (['r', 'b', 'q', 'k'].includes(piece.type)) {
                    // Get all squares within a certain distance
                    const maxDistance = piece.type === 'k' ? 1 : 7;

                    // Directions: horizontal, vertical, diagonal
                    const directions = [];

                    if (['r', 'q', 'k'].includes(piece.type)) {
                        // Horizontal and vertical
                        directions.push({ row: 0, col: 1 });
                        directions.push({ row: 0, col: -1 });
                        directions.push({ row: 1, col: 0 });
                        directions.push({ row: -1, col: 0 });
                    }

                    if (['b', 'q', 'k'].includes(piece.type)) {
                        // Diagonal
                        directions.push({ row: 1, col: 1 });
                        directions.push({ row: 1, col: -1 });
                        directions.push({ row: -1, col: 1 });
                        directions.push({ row: -1, col: -1 });
                    }

                    for (const dir of directions) {
                        for (let distance = 1; distance <= maxDistance; distance++) {
                            const newRow = row + dir.row * distance;
                            const newCol = col + dir.col * distance;

                            if (!this.isValidSquare(newRow, newCol)) break;

                            const targetPiece = this.board[newRow][newCol];

                            if (!targetPiece) {
                                // Empty square, can move here
                                moves.push({
                                    from: { row, col },
                                    to: { row: newRow, col: newCol }
                                });
                            } else {
                                // Occupied square
                                if (targetPiece.color !== piece.color) {
                                    // Can capture
                                    moves.push({
                                        from: { row, col },
                                        to: { row: newRow, col: newCol }
                                    });
                                }
                                break; // Can't move further in this direction
                            }
                        }
                    }
                }

                return moves;
            }

            /**
             * Check if a square is valid (on the board)
             */
            isValidSquare(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            /**
             * Get the FEN notation for the current position
             */
            getPositionFEN() {
                let fen = '';

                // Board position
                for (let row = 0; row < 8; row++) {
                    let emptyCount = 0;

                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];

                        if (piece) {
                            if (emptyCount > 0) {
                                fen += emptyCount;
                                emptyCount = 0;
                            }

                            let pieceChar = piece.type;
                            if (piece.color === 'white') {
                                pieceChar = pieceChar.toUpperCase();
                            }

                            fen += pieceChar;
                        } else {
                            emptyCount++;
                        }
                    }

                    if (emptyCount > 0) {
                        fen += emptyCount;
                    }

                    if (row < 7) {
                        fen += '/';
                    }
                }

                // Active color
                fen += ` ${this.currentPlayer.charAt(0)}`;

                // Simplified FEN (omitting castling, en passant, etc.)
                fen += ' - - 0 1';

                return fen;
            }

            /**
             * Convert a move to notation
             */
            getMoveNotation(move) {
                const files = 'abcdefgh';
                const fromFile = files[move.from.col];
                const fromRank = 8 - move.from.row;
                const toFile = files[move.to.col];
                const toRank = 8 - move.to.row;

                return `${fromFile}${fromRank}${toFile}${toRank}`;
            }

            /**
             * Parse move notation into a move object
             */
            parseNotation(notation) {
                if (notation.length !== 4) return null;

                const files = 'abcdefgh';
                const fromCol = files.indexOf(notation[0]);
                const fromRow = 8 - parseInt(notation[1]);
                const toCol = files.indexOf(notation[2]);
                const toRow = 8 - parseInt(notation[3]);

                if (fromCol < 0 || fromRow < 0 || toCol < 0 || toRow < 0) return null;
                if (fromCol > 7 || fromRow > 7 || toCol > 7 || toRow > 7) return null;

                return {
                    from: { row: fromRow, col: fromCol },
                    to: { row: toRow, col: toCol }
                };
            }

            /**
             * Evaluate the current position
             */
            evaluatePosition() {
                let score = 0;

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            const value = this.pieceValues[piece.type] || 0;
                            score += piece.color === 'white' ? value : -value;
                        }
                    }
                }

                return score;
            }

            /**
             * Check if a player is in check
             */
            isInCheck(color) {
                // Find the king
                let kingRow = -1;
                let kingCol = -1;

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.type === 'k' && piece.color === color) {
                            kingRow = row;
                            kingCol = col;
                            break;
                        }
                    }
                    if (kingRow !== -1) break;
                }

                if (kingRow === -1) return false; // No king found

                // Check if any opponent piece can capture the king
                const opponentColor = color === 'white' ? 'black' : 'white';
                const opponentMoves = this.getAllPossibleMoves(opponentColor);

                return opponentMoves.some(move =>
                    move.to.row === kingRow && move.to.col === kingCol
                );
            }

            /**
             * Execute an AI move
             */
            executeAIMove(move) {
                console.log("Executing AI move:", move);
                return this.executeMove(move);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM loaded, initializing chess system with optimized structure");

            // Create the chess game
            window.chessGame = new SimpleChess();

            // Create the optimized ARN
            window.chessARN = new OptimizedChessARN({
                autoSaveInterval: 300000 // Auto-save every 5 minutes
            });

            // Add a safety check for the log method
            if (!window.chessARN.log) {
                console.error("Log method not defined on ChessARN");
                window.chessARN.log = function (message, debug = false) {
                    console.log(`[ChessARN] ${message}`);
                };
            }

            // Set up event listeners for game controls
            document.getElementById('start-learning').addEventListener('click', () => {
                console.log("Start learning clicked");
                window.chessARN.start();
            });

            document.getElementById('pause-learning').addEventListener('click', () => {
                console.log("Pause learning clicked");
                window.chessARN.pause();
            });

            document.getElementById('stop-learning').addEventListener('click', () => {
                console.log("Stop learning clicked");
                window.chessARN.stop();
            });

            document.getElementById('single-move').addEventListener('click', () => {
                console.log("Single move clicked");
                window.chessARN.makeSingleMove();
            });

            // Add session control buttons if they don't exist
            const controlsDiv = document.querySelector('.controls');
            if (controlsDiv && !document.getElementById('save-session')) {
                const sessionControls = document.createElement('div');
                sessionControls.className = 'session-controls';
                sessionControls.innerHTML = `
      <button id="save-session" class="success">Save to File</button>
      <button id="load-knowledge" class="warning">Load from File</button>
      <button id="resume-session">Resume Session</button>
    `;
                controlsDiv.appendChild(sessionControls);

                // Add CSS for session controls
                const style = document.createElement('style');
                style.textContent = `
      .session-controls {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #ddd;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
    `;
                document.head.appendChild(style);
            }

            // Set up event listeners for session controls
            document.getElementById('save-session')?.addEventListener('click', () => {
                console.log("Save session clicked");
                window.chessARN.saveSession();
            });

            document.getElementById('load-knowledge')?.addEventListener('click', () => {
                console.log("Load knowledge clicked");
                window.chessARN.showLoadKnowledgeDialog();
            });

            document.getElementById('resume-session')?.addEventListener('click', () => {
                console.log("Resume session clicked");
                window.chessARN.resumeSession();
            });

            // Set up game speed change handler
            document.getElementById('game-speed').addEventListener('change', (e) => {
                const speed = parseInt(e.target.value);
                console.log("Speed changed to", speed);
                window.chessARN.options.gameDelay = speed;

                // If running, restart with new speed
                if (window.chessARN.isRunning && !window.chessARN.isPaused) {
                    clearInterval(window.chessARN.gameInterval);
                    window.chessARN.gameInterval = setInterval(() => window.chessARN.playNextMove(), speed);
                }
            });

            // Set up exploration rate slider
            const explorationSlider = document.getElementById('exploration-rate');
            if (explorationSlider) {
                explorationSlider.addEventListener('input', (e) => {
                    const rate = parseInt(e.target.value) / 100;
                    console.log("Exploration rate changed to", rate);
                    window.chessARN.setExplorationRate(rate);
                });
            }

            // Log initialization safely
            try {
                window.chessARN.log('ChessARN initialized with efficient move tree structure');
                window.chessARN.log('This system uses a hierarchical tree to minimize data size and improve performance');
                window.chessARN.log('Use "Save to File" to save your progress at any time');
            } catch (error) {
                console.error("Error logging initialization:", error);
            }

            console.log("Chess system initialization complete with optimized structure");
        });



    </script>
</body>

</html>